/*	// Set-up PIT interrupt
	// AT91F_AIC_ConfigureIt ( AT91C_BASE_AIC, AT91C_ID_SYS, RTTC_INTERRUPT_LEVEL,AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE, Periodic_Interval_Timer_handler);
	AT91F_AIC_ConfigureIt ( AT91C_BASE_AIC, AT91C_ID_SYS, 1,AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE, (void*)Periodic_Interval_Timer_handler);
	AT91C_BASE_PITC->PITC_PIMR = AT91C_PITC_PITEN | AT91C_PITC_PITIEN | PIV_200_MS;  //  IRQ enable CPC
	AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_SYS);
	*/
	//enable interrupts
    //enableIRQ();  



void vSER_ISR_Handler( void ) __attribute__ ((interrupt ("IRQ")));
void vSER_ISR_Wrapper( void ) __attribute__((naked));

void vSER_ISR_Wrapper( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT();

	/* Call the handler itself.  This must be a separate function as it uses
	the stack. */
	vSER_ISR_Handler();

	/* Restore the context of the task that is going to 
	execute next. This miglllht not be the same as the originally 
	interrupted task.*/
	portRESTORE_CONTEXT();
}


   cfg = kiss_fftr_alloc(FFT_NUMMER ,0 ,NULL, NULL); 	 //kiss_fft_cfg cfg = kiss_fft_alloc( FFT_NUMMER ,0 ,NULL, NULL);

	while (1)
	{
	//	AT91C_BASE_PIOA->PIO_SODR = LED_MASK;
	//	kiss_fftr( cfg , input , output );
	//	AT91C_BASE_PIOA->PIO_CODR = LED_MASK;
	//	kiss_fftr( cfg , input , output );
	}
